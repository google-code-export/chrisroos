<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <!--#include virtual="/includes/_head.html"-->
    <title>Test::Unit abstract test case - deferred until inspiration hits</title>
  </head>

  <body>
    
    <div id="doc3" class="yui-t4">
      <div id="hd">
        <div class="header">
          <!--#include virtual="/includes/_header.html"-->
        </div>
        <div class="navigation">
          
            <span class="previousPost">
              &larr; (older)
              <a class="previousPost" href="/blog/2006-07-17-some-realisations-about-testing" title="Some realisations about testing">
                
                Some realisations about testing
              </a> 
            </span>
          
          
            <span class="nextPost">
              <a class="nextPost" href="/blog/2006-07-28-textmate-and-env-ruby-no-such-file-or-directory" title="TextMate and &quot;env: ruby: No such file or directory&quot;">
                
                TextMate and &quot;env: ruby: No such file or directory&quot;
              </a> (newer) &rarr;
            </span>
          
        </div>
      </div>
      <div id="bd">
        <div id="yui-main">
          <div class="yui-b">
            <div class="yui-g">
              
              <h1>Test::Unit abstract test case</h1>
            
              <p class="postedOn">
                Posted by Chris Roos
                <span title="Mon, 17 Jul 2006 09:22:00">
                  Mon, 17 Jul 2006 09:22:00
                </span>
              </p>
          
              <p>Having found a <a href="http://blog.seagul.co.uk/articles/2006/07/17/some-realisations-about-testing">new way to structure my tests</a>, the need for some common setup shared by multiple test cases became apparent.</p>


	<p>I think the traditional way to do this was to create a subclass of TestCase to contain the common setup code and then subclass that for your individual test cases.  This is fine, but in <a href="http://ruby-doc.org/stdlib/libdoc/test/unit/rdoc/index.html">test/unit</a>, a TestCase with no tests causes an error.</p>


	<p>One solution would be to use a module to contain the common setup and include that in your test case.</p>


<div class="code"><pre><code class="ruby">
module CommonSetup
  def setup
    @stack = Stack.new
  end
end
class MyTest &lt; Test::Unit::TestCase
  include CommonSetup
  def test_should_accept_an_item_when_sent_push
    assert_nothing_raised { @stack.push(1) }
  end
end
</code></pre></div>

	<p>Although this is fine, I spent a short while creating an AbstractTestCase that doesn&#8217;t complain if no tests are specified.</p>


<div class="code"><pre><code class="ruby">
require 'test/unit'
class Test::Unit::AbstractTestCase &lt; Test::Unit::TestCase
  def default_test
    klass = self.class.to_s
    ancestors = (self.class.ancestors - [self.class]).collect { |ancestor| ancestor.to_s }
    super unless klass =~ /AbstractTestCase/ or ancestors.first =~ /AbstractTestCase/
  end
end
</code></pre></div>

	<p>Any test case (TestBase in this example) that inherits from AbstractTestCase can now contain setup and teardown methods but not have to worry about missing tests.  In order to maintain expected behaviour, any test case subclassed from TestBase will still complain if tests are missing.</p>


<div class="code"><pre><code class="ruby">
class TestBase &lt; Test::Unit::AbstractTestCase
  # 'No test were specified' error is not thrown
  def setup
    @bar = { :foo =&gt; 123 }
  end
end
class RealTest &lt; TestBase
  # Utilises TestBase#setup
  def test_example
    assert_equal 123, @bar[:foo]
  end
end
class ShouldErrorTest &lt; TestBase
  # 'No tests were specified' error
end
</code></pre></div>

	<p>I then figured that you may want more than one level of abstract test case, i.e. be able to define at the TestCase class level whether or not a test case was abstract.  This isn&#8217;t properly tested but it seems to work ok.</p>


	<p><strong>Note</strong> This isn&#8217;t doing exactly what I thought (the default test case is default_test, not test_default).  This works because it just creates an empty test in your test case.  This breaks behaviour in test cases that subclass your abstract test case as they too will already have at least one test defined.</p>


<div class="code"><pre><code class="ruby">
require 'test/unit'
class Test::Unit::TestCase
  class &lt;&lt; self
    def abstract
      self.class_eval do
        def test_default
        end
      end
    end
  end
end
</code></pre></div>

	<p>By sending the abstract message to any TestCase class, no errors will be reported when no tests are specified.  It does this by overriding the test_default method; which is the method that raises the error if no other tests are specified.</p>


<div class="code"><pre><code class="ruby">
class AbstractTest &lt; Test::Unit::TestCase
  abstract
  # 'No test were specified' error is not thrown
end
class NormalTest &lt; Test::Unit::TestCase
  # 'No test were specified' error
end
</code></pre></div>
        
              <div id="disqus_thread"></div>
              <script type="text/javascript" src="http://disqus.com/forums/deferred-until-inspiration-hits/embed.js"></script>
              <noscript>
                <p><a href="http://deferred-until-inspiration-hits.disqus.com/?url=ref">View the forum thread.</a></p>
              </noscript>

            </div>
          </div>
        </div>
        <div class="yui-b">
          <!--#include virtual="/includes/_navigation.html"-->
        </div>
      </div>
    </div>
    <div id="ft">
      <!-- Footer -->
    </div>
    
    <!--#include virtual="/includes/_twitter.html" -->
    <!--#include virtual="/includes/_delicious.html" -->
    <!--#include virtual="/includes/_google_analytics.html" -->
  </body>

</html>
